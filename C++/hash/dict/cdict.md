### 一, 散列表

1. 理解散列存在意义

解决内存使用尽可能少内存 (空间问题)

2. 简单定义一个散列函数 公式:

hash(k) = k % M  == 得到的值 是数组中id 数组中存储 实际 数据存储的地址

3. 散列冲突解决方案

#### 1, 散列函数设置原则

1. 确定性(determinism): 同一关键码总是被映射至同一地址
2. 快速性(efficiency): 	expected-O(1)
3. 满射性(surjection):	尽可能充分地覆盖整个散列空间
4. 均匀性(uniformity):	关键码映射到散列表各位置的概率尽量接近可有效避聚集(clustering)现象

几种常见散列函数介绍

##### ① 整数取余法

公式

```
hash(key) = key % M  ==》 key & (M - 1)
```

中M尽可能大于 key所有的值

注意: 上面公式中 key & (M - 1)   违反上面散列函数定义原则4了， 会在某一个数中聚集

事例:

若取 M = 2 ^ k, 其效果相当于

截取key的最后k位(bit), 前面的n - k 位对地址没有影响

```
M - 1 = [0 0 0 ... 0 | 1 1 1 ... 1]

key % M = key & (M - 1)
```

推理:发生冲突 iff 最后 k位相同 //发生冲突的概率大


结论: M为素数时, 数据对散列表的覆盖最充分, 分布最均匀



遍历散列表的步长(step) S 

公因子为G  

S和M最大

```
gcd(S, M)  = G 
```


##### ② MAD法

取余法的缺陷:

1. 不动点: 		无论表长M取值如何, 总有hash(0) == 0
2. 零阶均匀: 	[0, R)的关键码, 平均分配至M个桶; 但相邻关键码的散列地址也必相邻

一阶均匀: 邻近的关键码, 散列地址不再邻近       //更高级的均匀性呢

MAD = multiply-add-divide

取M为素数, a > 0, b > 0, a % M != 0

```
a ==> step 步长 

b ==> offset 偏移量  
```

公式 

```
hash(key) = ( a * key + b)  % M
```

##### ③ 平方取中间数

1. 数字分析 selecting digits

抽取key中的某几位, 构成地址

比如, 取十进制表示的奇数位

```
hash(1 2 3 4 5 6 7 8 9) = 1 3 5 7 9
```

2. 平方取中mid-square

取key ^ 2 的中间若干位, 构成地址

```
hash(123) = 512  // 保留 key ^ 2 == 123 ^ 2 =15129的中间3位

hash(1234567) = 556  // 1234567 ^ 2 == 15241 556 77489
```

为什么取集中的三位数呢？平方的原理分析

平方的原理分析

一个数据平方是通过 位移 和 叠加的

取到中间三位数  中间虚线区别

```
   |   | 10
   |   |10
   |  1|0 
   | 10|
   |10 |
  1|0  |
 10|   |
10 |   |
---|---|--
111|111|110
   |   |
```


##### ④ 折叠法汇总

1. 折叠法 (folding) : 将key分割成等宽的若干段，取其总和作为地址

```
hash(123 456 789) = 1368 // 123 + 456 + 789, --> 自左向右

hash(123 456 789) = 1566 // 123 + 654 + 789, --> 往复折返 
```

2. 位 异或法 XOR : 将key分割成等宽的二进制, 经 异或 运算得到地址

```
hash(110 011 011) = 110 // 110 ^ 011 ^ 011, --> 自左向右

hash(110 011 011) = 011 // 110 ^ 110 ^ 011, --> 往复折返
```

##### ⑤ 多项式法(字符串)

O(n)

```
hash( s = X0 X1 X2 ... X(n-1) )  == X0* a^(n - 1) + X1 * a ^ (n - 2) + ... + X(n - 2) * a^ 1 + X(n - 1)  // a 为一个常数
```

![]()



### 算法 前5字节与后面的27字节调换位置

```
//近似多项式， 但更快捷
static size_t hash_code(char s[])
{
	int h = 0;
	for (size_t n = strlen(s), i = 0; i < n; ++i)
	{
		h = (h << 5) | (h >> 27);
		h += (int)s[i];
	}
}
```

![]()

#### 1, 散列冲突

当M == 50时

k = 15 和 65时 时散列就冲突了


经过hash计算 的值都是 15


